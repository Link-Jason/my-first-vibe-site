<script>
    // Pong Game Logic 
    const ball = document.getElementById('ball');
    const paddleLeft = document.getElementById('paddleLeft');
    const paddleRight = document.getElementById('paddleRight');
    const scoreLeft = document.querySelector('.score-left');
    const scoreRight = document.querySelector('.score-right');
    const gameContainer = document.getElementById('gameContainer'); 
    
    const startButton = document.getElementById('startButton');
    const skeletonLeft = document.querySelector('.skeleton-left');
    const skeletonRight = document.querySelector('.skeleton-right');

    // **VIRTUAL GAME DIMENSIONS (Used for all logic/calculations)**
    const VIRTUAL_GAME_WIDTH = 600;
    const VIRTUAL_GAME_HEIGHT = 400;
    const VIRTUAL_BALL_SIZE = 20;
    const VIRTUAL_PADDLE_HEIGHT = 80;

    let ballX = VIRTUAL_GAME_WIDTH / 2;
    let ballY = VIRTUAL_GAME_HEIGHT / 2;
    
    // --- FASTER START SPEED KEPT ---
    const BASE_BALL_SPEED = 5; 
    let ballSpeedX = BASE_BALL_SPEED; 
    let ballSpeedY = 3; 
    // -------------------------------
    
    let paddleLeftY = 160;
    let paddleRightY = 160;
    
    let ballSpeedCap = 12; 
    const BALL_SPEED_INCREMENT_ON_HIT = 0.2; 
    let paddleSpeed = 2.0; 
    const AI_SPEED_INCREMENT = 0.2; 
    
    let userPaddleSpeed = 5; 
    let leftScore = 0;
    let rightScore = 0;

    const MAX_SCORE = 5; 
    let gameRunning = false; 

    // FIX: Global Touch Prevention (Most aggressive method)
    document.addEventListener('touchmove', function(e) {
        e.preventDefault();
    }, { passive: false });


    function getScaleRatio() {
        const currentWidth = gameContainer.offsetWidth;
        return currentWidth / VIRTUAL_GAME_WIDTH; 
    }

    function playPaddleHit(paddleElement) {
        let sound = document.getElementById('paddle-sound');
        // Check if sound element exists before trying to play
        if (!sound) return; 

        sound.pause(); 
        sound.currentTime = 0; 
        sound.playbackRate = 1 + (Math.random() * 0.5 - 0.25); 
        sound.play().catch(e => {});

        ball.classList.add('flash');
        paddleElement.classList.add('flash');
        
        setTimeout(() => {
            ball.classList.remove('flash');
            paddleElement.classList.remove('flash');
        }, 100); 
    }

    const keysPressed = {};
    document.addEventListener('keydown', (e) => { keysPressed[e.key.toLowerCase()] = true; });
    document.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });
    
    
    // ==============================================================
    // *** Touch Control Function (Unmodified) ***
    function handleTouchMove(e) {
        if (!gameRunning) return;
        e.preventDefault(); 
        
        const scaleRatio = getScaleRatio();
        const gameRect = gameContainer.getBoundingClientRect();
        
        const touchX = e.touches[0].clientX; 
        const relativeX = touchX - gameRect.left;
        let normalizedX = relativeX / scaleRatio;

        let newPaddleTop = (normalizedX / VIRTUAL_GAME_WIDTH) * VIRTUAL_GAME_HEIGHT;

        newPaddleTop -= (VIRTUAL_PADDLE_HEIGHT / 2);
        
        newPaddleTop = Math.max(0, Math.min(VIRTUAL_GAME_HEIGHT - VIRTUAL_PADDLE_HEIGHT, newPaddleTop));

        paddleLeftY = newPaddleTop;
    }

    function setupTouchControls() {
        gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
    }
    // ==============================================================


    function updateBall() {
        // --- MOVEMENT RESTORED TO FRAME-BASED (NO DELTA TIME) ---
        ballX += ballSpeedX;
        ballY += ballSpeedY;
        // --------------------------------------------------------

        if (ballY <= 0 || ballY >= VIRTUAL_GAME_HEIGHT - VIRTUAL_BALL_SIZE) {
            ballSpeedY = -ballSpeedY;
        }

        // Left Paddle Collision
        if (ballX <= 35 && ballY + VIRTUAL_BALL_SIZE >= paddleLeftY && ballY <= paddleLeftY + VIRTUAL_PADDLE_HEIGHT) {
            ballX = 35; 
            ballSpeedX *= -1;
            if (Math.abs(ballSpeedX) < ballSpeedCap) { ballSpeedX += Math.sign(ballSpeedX) * BALL_SPEED_INCREMENT_ON_HIT; }
            ballSpeedY += (Math.random() - 0.5) * 1.5;
            playPaddleHit(paddleLeft); 
        }
        
        // Right Paddle Collision
        if (ballX >= VIRTUAL_GAME_WIDTH - 35 - VIRTUAL_BALL_SIZE && ballY + VIRTUAL_BALL_SIZE >= paddleRightY && ballY <= paddleRightY + VIRTUAL_PADDLE_HEIGHT) {
            ballX = VIRTUAL_GAME_WIDTH - 35 - VIRTUAL_BALL_SIZE; 
            ballSpeedX *= -1; 
            if (Math.abs(ballSpeedX) < ballSpeedCap) { ballSpeedX += Math.sign(ballSpeedX) * BALL_SPEED_INCREMENT_ON_HIT; }
            ballSpeedY += (Math.random() - 0.5) * 1.5;
            playPaddleHit(paddleRight); 
        }

        if (ballX < 0) { rightScore++; scoreRight.textContent = rightScore; if (rightScore < MAX_SCORE) { paddleSpeed += AI_SPEED_INCREMENT; resetBall(1); } checkGameOver(); }
        if (ballX > VIRTUAL_GAME_WIDTH) { leftScore++; scoreLeft.textContent = leftScore; if (leftScore < MAX_SCORE) { paddleSpeed += AI_SPEED_INCREMENT; resetBall(-1); } checkGameOver(); }

        ball.style.left = (ballX / VIRTUAL_GAME_WIDTH * 100) + '%';
        ball.style.top = (ballY / VIRTUAL_GAME_HEIGHT * 100) + '%';
    }

    function updatePaddles() {
        const isTouchDevice = ('ontouchstart' in window);

        // DESKTOP CONTROLS 
        if (!isTouchDevice) {
            // --- MOVEMENT RESTORED TO FRAME-BASED (NO DELTA TIME) ---
            if (keysPressed['w'] || keysPressed['arrowup']) { paddleLeftY -= userPaddleSpeed; }
            if (keysPressed['s'] || keysPressed['arrowdown']) { paddleLeftY += userPaddleSpeed; }
            // --------------------------------------------------------
        }
        
        // AI Paddle Movement
        if (ballSpeedX > 0) { 
            const paddleCenterY = paddleRightY + VIRTUAL_PADDLE_HEIGHT / 2;
            // --- MOVEMENT RESTORED TO FRAME-BASED (NO DELTA TIME) ---
            if (paddleCenterY < ballY) { paddleRightY += paddleSpeed; } 
            else if (paddleCenterY > ballY) { paddleRightY -= paddleSpeed; }
            // --------------------------------------------------------
        }
        
        paddleLeftY = Math.max(0, Math.min(VIRTUAL_GAME_HEIGHT - VIRTUAL_PADDLE_HEIGHT, paddleLeftY));
        paddleRightY = Math.max(0, Math.min(VIRTUAL_GAME_HEIGHT - VIRTUAL_PADDLE_HEIGHT, paddleRightY));

        paddleLeft.style.top = (paddleLeftY / VIRTUAL_GAME_HEIGHT * 100) + '%';
        paddleRight.style.top = (paddleRightY / VIRTUAL_GAME_HEIGHT * 100) + '%';
    }

    function resetBall(direction = 1) { 
        ballX = VIRTUAL_GAME_WIDTH / 2;
        ballY = VIRTUAL_GAME_HEIGHT / 2;
        
        if (gameRunning) { 
            gameContainer.classList.add('glitch-screen');
            gameContainer.classList.add('shake-it');

            setTimeout(() => {
                gameContainer.classList.remove('shake-it');
                gameContainer.classList.remove('glitch-screen');
            }, 500); 
        }
        
        ballSpeedX = direction * BASE_BALL_SPEED; 
        // --- FASTER RESET SPEED KEPT ---
        ballSpeedY = (Math.random() - 0.5) * 6; 
        // -------------------------------
    }

    function checkGameOver() {
        if (leftScore >= MAX_SCORE || rightScore >= MAX_SCORE) {
            gameRunning = false; 
            
            gameContainer.classList.remove('shake-it');
            gameContainer.classList.remove('glitch-screen');
            gameContainer.style.animation = 'none'; 
            gameContainer.style.transform = 'translate(0, 0)'; 
            
            scoreLeft.style.display = 'none';
            scoreRight.style.display = 'none';
            
            const overlay = document.createElement('div');
            Object.assign(overlay.style, {
                position: 'fixed', top: '0', left: '0',
                width: '100%', height: '100%',
                display: 'flex', flexDirection: 'column',
                justifyContent: 'center', alignItems: 'center',
                zIndex: '9000', pointerEvents: 'auto'
            });
            document.body.appendChild(overlay);

            let winner = leftScore > rightScore ? "YOU" : "THE AI";
            let verb = leftScore > rightScore ? "WIN" : "WINS"; 
            
            const gameOverMessage = document.createElement('div');
            gameOverMessage.textContent = `GAME OVER. ${winner} ${verb}!`;
            
            Object.assign(gameOverMessage.style, {
                fontFamily: "'Press Start 2P', cursive",
                fontSize: '3vw', 
                color: '#FF00FF', 
                textShadow: '0 0 10px #FF00FF, 0 0 20px rgba(255, 0, 255, 0.5)',
                marginBottom: '4vh'
            });
            
            const playAgainButton = document.createElement('button');
            playAgainButton.textContent = "PLAY AGAIN?";
            
            playAgainButton.addEventListener('click', () => {
                gameContainer.style.animation = ''; 
                gameContainer.style.transform = ''; 
                overlay.remove(); 
                leftScore = 0; rightScore = 0;
                scoreLeft.textContent = '0'; scoreRight.textContent = '0';
                scoreLeft.style.display = 'block'; scoreRight.style.display = 'block';
                paddleLeftY = 160; paddleRightY = 160;
                paddleSpeed = 2.0;
                resetBall();
                gameRunning = true;
                requestAnimationFrame(gameLoop);
            });

            overlay.appendChild(gameOverMessage);
            overlay.appendChild(playAgainButton);
        }
    }

    function gameLoop() { // --- RESTORED TO ORIGINAL SIGNATURE ---
        if (gameRunning) { 
            // --- DELTA TIME CODE REMOVED ---
            
            updateBall();
            updatePaddles();
            requestAnimationFrame(gameLoop);
        } 
    }

    function launchGame() {
        gameRunning = true; 
        resetBall(); 
        updatePaddles(); 
        
        startButton.style.display = 'none';
        skeletonLeft.style.display = 'none';
        skeletonRight.style.display = 'none';
        
        setupTouchControls(); 

        requestAnimationFrame(gameLoop);
    }

    startButton.addEventListener('click', function startGameSequence() {
        let sound = document.getElementById('paddle-sound'); 
        if (sound) { sound.play().catch(e => {}); }

        const isTouchDevice = ('ontouchstart' in window);
        if (isTouchDevice) { this.textContent = "SOUND ACTIVATED. DRAG HORIZONTALLY TO CONTROL."; } 
        else { this.textContent = "SOUND ACTIVATED. USE W/S or ARROWS."; }

        this.classList.add('glitch-start');
        
        skeletonLeft.style.animation = 'none';
        skeletonRight.style.animation = 'none';

        launchGame(); 
        
        this.removeEventListener('click', startGameSequence);
    });
</script>